variables:
  DOCKER_IMAGE: registry.gitlab.com/sep490_g80/transit-link-backend
  USER: transitlink
  PROJECT_DIR: "/srv/transitlink"
  BACKUPS_DIR: "/backups"
  GRADLE_VERSION: "8.14.3-jdk21-alpine"
  DOCKER_VERSION: "28.3.3"
  ALPINE_VERSION: "3.22.1"
  CURL_VERSION: "8.15.0"
  APP_DB_CONTAINER: "transitlink-db"
  APP_DB_NAME: "transitlink"
  APP_CONTAINER: "transitlink"
  KEYCLOAK_DB_CONTAINER: "keycloak-db"
  KEYCLOAK_DB_NAME: "keycloak"
  KEYCLOAK_CONTAINER: "keycloak"
  POSTGRES_IMAGE: bitnami/postgresql:17.5.0-debian-12-r20
  KEYCLOAK_IMAGE: bitnami/keycloak:26.3.1-debian-12-r2
  REDIS_IMAGE: bitnami/redis:8.0.3-debian-12-r2

.rules_changes: &changes
  changes:
    - "**/*.java"
    - "build.gradle.kts"
    - "gradle.properties.kts"
    - "src/**/*"

.ssh_setup: &ssh_setup
  before_script:
    - apk add --no-cache openssh
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

stages:
  - test
  - merge
  - docker-publish
  - backup
  - deploy
  - cleanup

unit-tests:
  stage: test
  image: gradle:${GRADLE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH =~ /^(feat|fix|hotfix)\/.+/'
      <<: *changes
      when: always
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "dev"'
      <<: *changes
      when: always
    - when: never
  script:
    - gradle clean unitTest --no-daemon --stacktrace --info
  artifacts:
    when: always
    paths:
      - build/jacoco/unitTest.exec
      - build/test-results/unitTest/
      - build/reports/tests/unitTest
    reports:
      junit:
        - build/test-results/unitTest/TEST-*.xml
    expire_in: 1 week

integration-tests:
  stage: test
  image: gradle:${GRADLE_VERSION}
  services:
    - name: docker:${DOCKER_VERSION}-dind
      alias: docker
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
    TESTCONTAINERS_HOST_OVERRIDE: docker
    TESTCONTAINERS_RYUK_DISABLED: "true"
    TESTCONTAINERS_CHECKS_DISABLE: "true"
    GRADLE_OPTS: "-Xmx2g -Dorg.gradle.daemon=false"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH =~ /^(feat|fix|hotfix)\/.+/'
      <<: *changes
      when: always
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "dev"'
      <<: *changes
      when: always
    - when: never
  before_script:
    - apk add --no-cache docker-cli curl
    - until docker info; do echo "Waiting for docker to start..."; sleep 1; done
    - docker version
    - gradle --version
    - docker system prune -f || true
    - docker pull $POSTGRES_IMAGE
    - docker pull $REDIS_IMAGE
    - docker pull $KEYCLOAK_IMAGE
    - echo "$ENV_FILE" > .env
    - export $(cat .env | xargs)
  script:
    - gradle integrationTest --no-daemon --stacktrace --info
  after_script:
    - docker container prune -f || true
    - docker image prune -f || true
  artifacts:
    when: always
    paths:
      - build/jacoco/integrationTest.exec
      - build/test-results/integrationTest/
      - build/reports/tests/integrationTest/
    reports:
      junit:
        - build/test-results/integrationTest/TEST-*.xml    
    expire_in: 1 week
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

generate_report:
  stage: test
  image: gradle:${GRADLE_VERSION}
  needs:
    - job: "unit-tests"
      artifacts: true
    - job: "integration-tests"
      artifacts: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH =~ /^(feat|fix|hotfix)\/.+/'
      <<: *changes
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "dev"'
      <<: *changes
      when: on_success
    - when: never
  script:
    - gradle jacocoCombinedTestReport --no-daemon --stacktrace --info
  artifacts:
    when: always
    paths:
      - build/reports/jacoco/combined
      - build/reports/jacoco/jacocoCombinedTestReport      
    expire_in: 1 week

push-report:
  stage: test
  image: gradle:${GRADLE_VERSION}
  needs:
    - job: "generate_report"
      artifacts: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "dev"'
      <<: *changes
      when: on_success
    - when: never  
  before_script:
    - echo "$SONAR_TOKEN"
  script:
    - gradle sonar

create_merge_dev:
  stage: merge
  image: curlimages/curl:$CURL_VERSION
  needs:
    - job: "unit-tests"
    - job: "integration-tests"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH =~ /^(feat|fix)\/.+/'
      <<: *changes
      when: on_success
    - when: never
  before_script:
    - apk add --no-cache jq
  script:
    - |
      echo "Creating merge request to dev branch..."
      
      EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?source_branch=$CI_COMMIT_REF_NAME&target_branch=dev&state=opened" | \
        jq '.[0].iid // empty')
      
      if [ -n "$EXISTING_MR" ]; then
        echo "Merge request to dev already exists: !$EXISTING_MR"
        echo "DEV_MR_IID=$EXISTING_MR" >> merge_request_dev.env
      else

        RESPONSE=$(curl -s -X POST \
          --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
          --header "Content-Type: application/json" \
          --data '{
            "source_branch": "'$CI_COMMIT_REF_NAME'",
            "target_branch": "dev",
            "title": "[DEV] '$CI_COMMIT_TITLE'",
            "description": "**Auto MR to Development Branch**\n\n**Branch**: `'$CI_COMMIT_REF_NAME'` → `dev`\n**Commit**: '$CI_COMMIT_SHA'\n🚀 **Pipeline**: ['$CI_PIPELINE_URL']('$CI_PIPELINE_URL')\n\n---\n\n**Changes**:\n'$CI_COMMIT_DESCRIPTION'\n\n**Test Results**: All tests passed\n**Coverage Report**: Available in pipeline artifacts",
            "remove_source_branch": true,
            "squash": false,
            "labels": "auto-mr,development"
          }' \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests")
        
        DEV_MR_IID=$(echo $RESPONSE | jq '.iid')
        
        if [ -n "$DEV_MR_IID" ]; then
          echo "Merge request to dev created: !$DEV_MR_IID"
          echo "DEV_MR_IID=$DEV_MR_IID" >> merge_request_dev.env
        else
          echo "Failed to create merge request to dev"
          echo "Response: $RESPONSE"
          exit 1
        fi
      fi
  artifacts:
    reports:
      dotenv: merge_request_dev.env
    expire_in: 1 hour

create_merge_main:
  stage: merge
  image: curlimages/curl:$CURL_VERSION
  needs:
    - job: "unit-tests"
    - job: "integration-tests"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH =~ /^hotfix\/.+/'
      <<: *changes
      when: on_success
    - when: never
  before_script:
    - apk add --no-cache jq
  script:
    - |
      echo "Creating merge request to main branch..."
      
      EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?source_branch=$CI_COMMIT_REF_NAME&target_branch=main&state=opened" | \
        jq '.[0].iid // empty')
      
      if [ -n "$EXISTING_MR" ]; then
        echo "Merge request to main already exists: !$EXISTING_MR"
        echo "MAIN_MR_IID=$EXISTING_MR" >> merge_request_main.env
      else
        RESPONSE=$(curl -s -X POST \
          --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
          --header "Content-Type: application/json" \
          --data '{
            "source_branch": "'$CI_COMMIT_REF_NAME'",
            "target_branch": "main",
            "title": "[HOTFIX] '$CI_COMMIT_TITLE'",
            "description": "**HOTFIX - Critical Fix to Production**\n\n **Branch**: `'$CI_COMMIT_REF_NAME'` → `main`\n **Commit**: '$CI_COMMIT_SHA'\n🚀 **Pipeline**: ['$CI_PIPELINE_URL']('$CI_PIPELINE_URL')\n\n---\n\n**Hotfix Details**:\n'$CI_COMMIT_DESCRIPTION'\n\n⚠️ **Priority**: HIGH\n✅ **Test Results**: All tests passed\n🔍 **Review Required**: Yes\n\n**Post-merge Actions**:\n- [ ] Deploy to production\n- [ ] Monitor for issues\n- [ ] Merge back to dev branch",
            "remove_source_branch": false,
            "squash": false,
            "labels": "hotfix,critical,production"
          }' \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests")
        
        MAIN_MR_IID=$(echo $RESPONSE | jq '.iid')
        
        if [ -n "$MAIN_MR_IID" ]; then
          echo "Hotfix merge request to main created: !$MAIN_MR_IID"
          echo "MAIN_MR_IID=$MAIN_MR_IID" >> merge_request_main.env
        else
          echo "Failed to create hotfix merge request to main"
          echo "Response: $RESPONSE"
          exit 1
        fi
      fi
  artifacts:
    reports:
      dotenv: merge_request_main.env
    expire_in: 1 hour

approve_merge_request:
  stage: merge
  image: curlimages/curl:$CURL_VERSION
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH =~ /^(feat|fix|hotfix)\/.+/'
      <<: *changes
      when: manual
      allow_failure: false
    - when: never
  needs:
    - job: "create_merge_dev"
      artifacts: true
      optional: true
    - job: "create_merge_main" 
      artifacts: true
      optional: true
  before_script:
    - apk add --no-cache jq
  script:
    - |
      echo "Starting merge approval process..."
      
      if [[ "$CI_COMMIT_BRANCH" =~ ^(feat|fix)/.+ ]]; then
        MR_IID=$DEV_MR_IID
        TARGET_BRANCH="dev"
        echo "Processing merge to dev branch: !$MR_IID"
      elif [[ "$CI_COMMIT_BRANCH" =~ ^hotfix/.+ ]]; then
        MR_IID=$MAIN_MR_IID  
        TARGET_BRANCH="main"
        echo "Processing hotfix merge to main branch: !$MR_IID"
      else
        echo "Unknown branch pattern: $CI_COMMIT_BRANCH"
        exit 1
      fi
      
      if [ -z "$MR_IID" ]; then
        echo "MR_IID not found. Please ensure create_merge_* job completed successfully."
        exit 1
      fi
      
      echo "Checking merge request status..."
      MR_INFO=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$MR_IID")
      
      MR_STATUS=$(echo $MR_INFO | jq '.detailed_merge_status // empty')
      MR_STATE=$(echo $MR_INFO | jq '.state // empty')
      
      echo "MR State: $MR_STATE"
      echo "Merge Status: $MR_STATUS"
      
      if [ "$MR_STATE" != "opened" ]; then
        echo "Merge request is not open. Current state: $MR_STATE"
        exit 1
      fi
      
      if [ "$MR_STATUS" = "can_be_merged" ] || [ "$MR_STATUS" = "mergeable" ]; then
        echo "Merge request is ready to merge"
        
        echo "Executing merge..."
        MERGE_RESPONSE=$(curl -s -X PUT \
          --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
          --header "Content-Type: application/json" \
          --data '{
            "merge_commit_message": "Auto merge: '$CI_COMMIT_TITLE' (Pipeline #'$CI_PIPELINE_ID')\n\nBranch: '$CI_COMMIT_REF_NAME' → '$TARGET_BRANCH'\nCommit: '$CI_COMMIT_SHA'\nPipeline: '$CI_PIPELINE_URL'",
            "should_remove_source_branch": true,
            "squash": false
          }' \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$MR_IID/merge")
        
        MERGE_STATE=$(echo $MERGE_RESPONSE | jq '.state // empty')
        
        if [ "$MERGE_STATE" = "merged" ]; then
          echo "Merge request !$MR_IID merged successfully to $TARGET_BRANCH!"
          
          MERGE_SHA=$(echo $MERGE_RESPONSE | jq '.merge_commit_sha // empty')
          echo "Merge commit SHA: $MERGE_SHA"
          
          echo "MERGED_TO_BRANCH=$TARGET_BRANCH" >> merge_result.env
          echo "MERGE_COMMIT_SHA=$MERGE_SHA" >> merge_result.env
          echo "MERGED_MR_IID=$MR_IID" >> merge_result.env
          
        else
          echo "Failed to merge. Response: $MERGE_RESPONSE"
          exit 1
        fi
      else
        echo "Cannot merge. Status: $MR_STATUS"
        
        case $MR_STATUS in
          "ci_must_pass")
            echo "Reason: CI pipeline must pass before merge"
            ;;
          "discussions_not_resolved")
            echo "Reason: All discussions must be resolved"
            ;;
          "not_approved")
            echo "Reason: Merge request requires approval"
            ;;
          "conflict")
            echo "Reason: Merge conflicts exist"
            ;;
          "draft_status")
            echo "Reason: Merge request is in draft status"
            ;;
          *)
            echo "Reason: $MR_STATUS"
            ;;
        esac
        
        echo "Please check the merge request manually: $CI_PROJECT_URL/-/merge_requests/$MR_IID"
        exit 1
      fi

build-and-push-image:
  stage: docker-publish  
  image: docker:${DOCKER_VERSION}
  services:
    - docker:${DOCKER_VERSION}-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "dev"'
      <<: *changes
      when: on_success
    - when: never
  needs:
    - job: "unit-tests"
      artifacts: false
    - job: "integration-tests"
      artifacts: false
  script:
      - set -e
      - docker buildx build --platform linux/amd64 -t $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA .
      - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
      - |
        if [[ "$CI_COMMIT_REF_NAME" == "dev" || "$CI_COMMIT_REF_NAME" == "main" ]]; then
          docker tag $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA $DOCKER_IMAGE:$CI_COMMIT_REF_NAME
          docker push $DOCKER_IMAGE:$CI_COMMIT_REF_NAME
        fi
      - docker push $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA

backup_app_db:
  stage: backup
  image: alpine:${ALPINE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      <<: *changes
      when: on_success
    - when: never
  needs:
    - job: build-and-push-image
      artifacts: false
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  <<: *ssh_setup
  script:
    - set -e
    - |
      ssh $USER@$HOST << EOF
        set -e
        mkdir -p "$BACKUPS_DIR/database/$APP_DB_NAME"
        cd $PROJECT_DIR/script
        ./pg_tool.sh backup -c $APP_DB_CONTAINER -n $APP_DB_NAME -u $APP_DB_USER -p $APP_DB_PASS -f $CI_COMMIT_SHORT_SHA --backup-dir $BACKUPS_DIR/database/$APP_DB_NAME
        echo "=== API Database Backup Info ==="
        cat $BACKUPS_DIR/database/$APP_DB_NAME/$CI_COMMIT_SHORT_SHA-*.info || echo "No API backup info found"
      EOF

backup_keycloak_db:
  stage: backup
  image: alpine:${ALPINE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      <<: *changes
      when: on_success
    - when: never
  needs:
    - job: build-and-push-image
      artifacts: false
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  <<: *ssh_setup
  script:
    - set -e
    - |
      ssh $USER@$HOST << EOF
        set -e
        mkdir -p "$BACKUPS_DIR/database/$KEYCLOAK_DB_NAME"
        cd $PROJECT_DIR/script
        ./pg_tool.sh backup -c $KEYCLOAK_DB_CONTAINER -n $KEYCLOAK_DB_NAME -u $KEYCLOAK_DB_USER -p $KEYCLOAK_DB_PASS -f $CI_COMMIT_SHORT_SHA --backup-dir $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME
        echo "=== Keycloak Database Backup Info ==="
        cat $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/$CI_COMMIT_SHORT_SHA-*.info || echo "No Keycloak backup info found"
      EOF

backup_transitlink_data:
  stage: backup
  image: alpine:${ALPINE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      <<: *changes
      when: on_success
    - when: never
  needs:
    - job: build-and-push-image
      artifacts: false
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  <<: *ssh_setup
  script:
    - set -e
    - |
      ssh $USER@$HOST << EOF
        set -e
        mkdir -p "$BACKUPS_DIR/transitlink"
        TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
        echo "Backing up entire transitlink directory..."
        tar -czf $BACKUPS_DIR/transitlink/$CI_COMMIT_SHORT_SHA-transitlink-\$TIMESTAMP.tar.gz -C $PROJECT_DIR transitlink/
        echo "Transitlink backup: $CI_COMMIT_SHORT_SHA-transitlink-\$TIMESTAMP.tar.gz
        Source: $PROJECT_DIR/transitlink/
        Size: \$(du -sh $BACKUPS_DIR/transitlink/$CI_COMMIT_SHORT_SHA-transitlink-\$TIMESTAMP.tar.gz | cut -f1)
        Total files: \$(find $PROJECT_DIR/transitlink -type f 2>/dev/null | wc -l)
        Total dirs: \$(find $PROJECT_DIR/transitlink -type d 2>/dev/null | wc -l)
        Commit: $CI_COMMIT_SHORT_SHA
        Branch: $CI_COMMIT_REF_NAME
        Date: \$(date)
        Contents:
        \$(ls -la $PROJECT_DIR/transitlink/)" > $BACKUPS_DIR/transitlink/$CI_COMMIT_SHORT_SHA-transitlink-\$TIMESTAMP.info
        echo "=== Transitlink Directory Backup ==="
        cat $BACKUPS_DIR/transitlink/$CI_COMMIT_SHORT_SHA-transitlink-*.info 2>/dev/null || echo "No transitlink backup info found"
      EOF

deploy:
  stage: deploy
  image: alpine:${ALPINE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      <<: *changes
      when: on_success
    - when: never
  needs:
    - job: backup_app_db
      artifacts: false
    - job: backup_keycloak_db
      artifacts: false
    - job: backup_transitlink_data
      artifacts: false
  <<: *ssh_setup
  script:
    - ssh $USER@$HOST "mkdir -p $BACKUPS_DIR/api"
    - set -e
    - |
      cat > compose.api.yaml << EOF
      services:
        transitlink:
          image: $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA
      EOF
    - scp compose.api.yaml $USER@$HOST:$BACKUPS_DIR/api/api-$CI_COMMIT_SHORT_SHA.yaml
    - |
      ssh $USER@$HOST << EOF
        set -e
        cd $PROJECT_DIR
        ln -sf $BACKUPS_DIR/api/api-$CI_COMMIT_SHORT_SHA.yaml compose.api.yaml
        docker compose -f compose.yaml -f compose.prod.yaml -f compose.api.yaml -f compose.web.yaml --env-file .env.prod down || true
        docker compose -f compose.yaml -f compose.prod.yaml -f compose.api.yaml -f compose.web.yaml --env-file .env.prod up -d
        echo "Waiting for service to be ready..."
        timeout 300 sh -c 'until curl -f http://localhost/actuator/health; do echo "Waiting..."; sleep 5; done' || echo "Health check timeout - please verify manually"
        echo "deployment completed successfully!"
        echo "Deployed version: $CI_COMMIT_SHORT_SHA"
        echo "Current override: \$(readlink compose.api.yaml)"
      EOF

rollback:
  stage: deploy
  image: alpine:${ALPINE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "main"'
      <<: *changes
      when: manual
    - when: never
  variables:
    ROLLBACK_TAG: ""
  <<: *ssh_setup
  script:
    - |
      if [ -z "$ROLLBACK_TAG" ]; then
        echo "ERROR: ROLLBACK_TAG variable is required"
        echo "Usage: Set ROLLBACK_TAG to commit SHA you want to rollback to"
        exit 1
      fi
      ssh $USER@$HOST << EOF
        set -e
        echo "=== Starting Rollback to $ROLLBACK_TAG ==="
        echo "Checking backup files..."
        BACKUP_ERRORS=0
        if [ ! -f "$BACKUPS_DIR/database/$APP_DB_NAME/$ROLLBACK_TAG-"*.dump ]; then
          echo "ERROR: Database backup for $APP_DB_NAME with tag $ROLLBACK_TAG not found!"
          ls -la $BACKUPS_DIR/database/$APP_DB_NAME/$ROLLBACK_TAG-* 2>/dev/null || echo "No backups found for this tag"
          BACKUP_ERRORS=\$((BACKUP_ERRORS + 1))
        fi
        if [ ! -f "$BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/$ROLLBACK_TAG-"*.dump ]; then
          echo "ERROR: Database backup for $KEYCLOAK_DB_NAME with tag $ROLLBACK_TAG not found!"
          ls -la $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/$ROLLBACK_TAG-* 2>/dev/null || echo "No backups found for this tag"
          BACKUP_ERRORS=\$((BACKUP_ERRORS + 1))
        fi
        if [ ! -f "$BACKUPS_DIR/transitlink/$ROLLBACK_TAG-transitlink-"*.tar.gz ]; then
          echo "ERROR: Transitlink data backup with tag $ROLLBACK_TAG not found!"
          ls -la $BACKUPS_DIR/transitlink/$ROLLBACK_TAG-* 2>/dev/null || echo "No backups found for this tag"
          BACKUP_ERRORS=\$((BACKUP_ERRORS + 1))
        fi
        if [ ! -f "$BACKUPS_DIR/api/api-$ROLLBACK_TAG.yaml" ]; then
          echo "ERROR: Compose file api-$ROLLBACK_TAG.yaml not found!"
          ls -la $BACKUPS_DIR/api/api-*.yaml 2>/dev/null || echo "No compose backups found"
          BACKUP_ERRORS=\$((BACKUP_ERRORS + 1))
        fi
        if [ \$BACKUP_ERRORS -gt 0 ]; then
          echo "Found \$BACKUP_ERRORS errors. Aborting rollback."
          exit 1
        fi
        echo "All backup files found. Proceeding with rollback..."
        echo "=== Restoring Databases ==="
        cd $PROJECT_DIR/script
        APP_DB_BACKUP=\$(ls -t $BACKUPS_DIR/database/$APP_DB_NAME/$ROLLBACK_TAG-*.dump | head -1)
        KEYCLOAK_DB_BACKUP=\$(ls -t $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/$ROLLBACK_TAG-*.dump | head -1)
        echo "Restoring $APP_DB_NAME database..."
        ./pg_tool.sh restore "\$APP_DB_BACKUP" \
          -c $APP_DB_CONTAINER \
          -n $APP_DB_NAME \
          -u $APP_DB_USER \
          -p $APP_DB_PASS \
          -s $APP_CONTAINER \
          --backup-dir $BACKUPS_DIR/database/$APP_DB_NAME \
          -y -d
        echo "Restoring $KEYCLOAK_DB_NAME database..."  
        ./pg_tool.sh restore "\$KEYCLOAK_DB_BACKUP" \
          -c $KEYCLOAK_DB_CONTAINER \
          -n $KEYCLOAK_DB_NAME \
          -u $KEYCLOAK_DB_USER \
          -p $KEYCLOAK_DB_PASS \
          -s $KEYCLOAK_CONTAINER \
          --backup-dir $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME \
          -y -d
        echo "=== Restoring Transitlink Data ==="
        TRANSITLINK_BACKUP=\$(ls -t $BACKUPS_DIR/transitlink/$ROLLBACK_TAG-transitlink-*.tar.gz | head -1)
        echo "Extracting transitlink data from backup..."
        tar -xzvf "\$TRANSITLINK_BACKUP" -C $PROJECT_DIR
        echo "=== Updating Compose Configuration ==="
        cd $PROJECT_DIR
        ln -sf $BACKUPS_DIR/api/api-$ROLLBACK_TAG.yaml compose.api.yaml
        echo "=== Starting Applications ==="
        docker compose -f compose.yaml -f compose.prod.yaml -f compose.api.yaml --env-file .env.prod up -d
        echo "Waiting for services to start..."
        sleep 10
        echo "=== Health Check ==="
        echo "Checking database connections..."
        docker exec $APP_DB_CONTAINER pg_isready -U $APP_DB_USER -d $APP_DB_NAME || echo "Warning: App DB not ready"
        docker exec $KEYCLOAK_DB_CONTAINER pg_isready -U $KEYCLOAK_DB_USER -d $KEYCLOAK_DB_NAME || echo "Warning: Keycloak DB not ready"
        echo "Checking container status..."
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo "=== Rollback Summary ==="
        echo "Target Tag: $ROLLBACK_TAG"
        echo "App DB restored from: \$(basename "\$APP_DB_BACKUP")"
        echo "Keycloak DB restored from: \$(basename "\$KEYCLOAK_DB_BACKUP")"
        echo "Transitlink data restored from: \$(basename "\$TRANSITLINK_BACKUP")"
        echo "Compose file: api-$ROLLBACK_TAG.yaml"
        echo "Completed at: \$(date)"
        echo ""
        echo "=== Restored Backup Details ==="
        cat $BACKUPS_DIR/database/$APP_DB_NAME/$ROLLBACK_TAG-*.info 2>/dev/null || echo "No app DB backup info"
        echo ""
        cat $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/$ROLLBACK_TAG-*.info 2>/dev/null || echo "No keycloak DB backup info"
        echo ""
        cat $BACKUPS_DIR/transitlink/$ROLLBACK_TAG-transitlink-*.info 2>/dev/null || echo "No transitlink backup info"
        echo "=== Rollback to $ROLLBACK_TAG completed successfully! ==="
      EOF

cleanup_backups:
  stage: cleanup
  image: alpine:${ALPINE_VERSION}
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: always
    - when: never
  <<: *ssh_setup
  script:
    - |
      ssh $USER@$HOST << EOF
        set -e
        echo "=== Cleaning up old backups ==="
        echo "Cleaning $APP_DB_NAME backups..."
        # Keep 5 newest .dump, .info, .sql.gz files
        ls -t $BACKUPS_DIR/database/$APP_DB_NAME/*.dump 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        ls -t $BACKUPS_DIR/database/$APP_DB_NAME/*.info 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        ls -t $BACKUPS_DIR/database/$APP_DB_NAME/*.sql.gz 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        
        echo "Cleaning $KEYCLOAK_DB_NAME backups..."
        ls -t $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/*.dump 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        ls -t $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/*.info 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        ls -t $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/*.sql.gz 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        
        echo "Cleaning transitlink data backups..."
        ls -t $BACKUPS_DIR/transitlink/*.tar.gz 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        ls -t $BACKUPS_DIR/transitlink/*.info 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        
        echo "Cleaning API compose files..."
        ls -t $BACKUPS_DIR/api/api-*.yaml 2>/dev/null | tail -n +6 | xargs -I {} rm -f {}
        
        echo "=== Cleanup Summary ==="
        echo "Remaining $APP_DB_NAME backups:"
        ls -l $BACKUPS_DIR/database/$APP_DB_NAME/ 2>/dev/null || echo "No backups found"
        echo "Remaining $KEYCLOAK_DB_NAME backups:"
        ls -l $BACKUPS_DIR/database/$KEYCLOAK_DB_NAME/ 2>/dev/null || echo "No backups found"
        echo "Remaining transitlink backups:"
        ls -l $BACKUPS_DIR/transitlink/ 2>/dev/null || echo "No backups found"
        echo "Remaining API compose files:"
        ls -l $BACKUPS_DIR/api/api-*.yaml 2>/dev/null || echo "No compose files found"
        echo "Cleanup completed at: \$(date)"
      EOF